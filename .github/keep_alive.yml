# .github/workflows/keep_alive.yml
# Emp√™che les apps Streamlit Community Cloud de passer en veille
# en les visitant avec un navigateur headless toutes les 6 heures.
#
# ‚ö†Ô∏è  Un simple curl ne suffit PAS : Streamlit sert une page JS
#     qui doit s'ex√©cuter pour r√©veiller le conteneur.
#     ‚Üí On utilise Playwright (Chromium) pour simuler une vraie visite.
#
# Pour ajouter une nouvelle app : ajoutez une entr√©e dans le tableau "apps".

name: Keep Streamlit Apps Alive

on:
  schedule:
    - cron: "0 */6 * * *"   # Toutes les 6 h : 00:00, 06:00, 12:00, 18:00 UTC
  workflow_dispatch:          # Permet un d√©clenchement manuel depuis GitHub

jobs:
  ping:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright + Chromium
        run: |
          npm i -D playwright
          npx playwright install chromium --with-deps

      - name: Wake up Streamlit apps
        run: |
          node << 'SCRIPT'
          const { chromium } = require('playwright');

          // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          // LISTE DES APPS ‚Äî Ajoutez vos apps ici
          // ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
          const apps = [
            { name: "Portfolio",               url: "https://portfolio-nicodeme.streamlit.app/" },
            { name: "Analyseur de Sentiment",  url: "https://analyseur-sentiment.streamlit.app/" },
            { name: "Ecosystem Simulator",     url: "https://ecosystem-simulator.streamlit.app/" },
            // { name: "Nouvelle App",          url: "https://nouvelle-app.streamlit.app/" },
          ];

          const WAKE_TIMEOUT  = 120_000;  // Timeout navigation : 2 min
          const SETTLE_DELAY  =  15_000;  // Pause apr√®s chargement : 15 s

          (async () => {
            const browser = await chromium.launch();
            const results = [];

            for (const app of apps) {
              const timestamp = new Date().toISOString();
              console.log(`\nüîî [${timestamp}] Ping ${app.name}`);
              console.log(`   URL: ${app.url}`);

              try {
                const context = await browser.newContext();
                const page = await context.newPage();

                // Visite la page ‚Äî le JS Streamlit s'ex√©cute et r√©veille le conteneur
                await page.goto(app.url, {
                  waitUntil: 'networkidle',
                  timeout: WAKE_TIMEOUT,
                });

                // Laisse le temps au conteneur de d√©marrer compl√®tement
                await page.waitForTimeout(SETTLE_DELAY);

                const title = await page.title();
                console.log(`   Titre de la page : "${title}"`);
                console.log(`‚úÖ ${app.name} OK`);
                results.push({ app: app.name, status: 'ok' });

                await context.close();
              } catch (err) {
                console.error(`‚ùå ${app.name} FAILED: ${err.message}`);
                results.push({ app: app.name, status: 'failed', error: err.message });
              }
            }

            await browser.close();

            // R√©sum√© final
            console.log('\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ R√âSUM√â ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            for (const r of results) {
              const icon = r.status === 'ok' ? '‚úÖ' : '‚ùå';
              console.log(`${icon} ${r.app}`);
            }

            const failed = results.filter(r => r.status === 'failed');
            if (failed.length > 0) {
              console.error(`\n‚ö†Ô∏è  ${failed.length} app(s) en √©chec.`);
              process.exit(1);  // Marque le workflow comme failed dans GitHub
            }
          })();
          SCRIPT
